import { Resolver, AwilixContainer, ResolverOptions, Constructor, ClassOrFunctionReturning, FunctionReturning } from 'awilix';
import { Socket } from 'socket.io';
declare type MethodName = string | number | null;
/**
 * Creates either a function invoker or a class invoker, based on whether
 * the argument can be classified as a class or not. Uses Awilix' `isClass` utility.
 *
 * @param functionOrClass
 * The function or class to invoke.
 *
 * @param opts
 * Resolver options for the class/function.
 */
export declare function makeInvoker<T>(functionOrClass: ClassOrFunctionReturning<T>, opts?: ResolverOptions<T>): (methodToInvoke: MethodName) => (this: Socket & {
    container: AwilixContainer;
}, ...rest: any[]) => any;
/**
 * Returns a function that when called with a name,
 * returns another function to be used as Koa middleware.
 * That function will run `fn` with the container cradle as the
 * only parameter, and then call the `methodToInvoke` on
 * the result.
 *
 * @param, {Function} fn
 * @return {(methodToInvoke: string) => (...args) => void}
 */
export declare function makeFunctionInvoker<T>(fn: FunctionReturning<T>, opts?: ResolverOptions<T>): (methodToInvoke: MethodName) => (this: Socket & {
    container: AwilixContainer;
}, ...rest: any[]) => any;
/**
 * Same as `makeInvoker` but for classes.
 *
 * @param  {Class} Class
 * @return {(methodToInvoke: string) => (...args) => void}
 */
export declare function makeClassInvoker<T>(Class: Constructor<T>, opts?: ResolverOptions<T>): (methodToInvoke: MethodName) => (this: Socket & {
    container: AwilixContainer;
}, ...rest: any[]) => any;
/**
 * Returns a function that when called with a method name,
 * returns another function to be used as Koa middleware.
 * That function will run `container.build(resolver)`, and
 * then call the method on the result, passing in the Koa context
 * and `next()`.
 *
 * @param, {Resolver} resolver
 * @return {(methodToInvoke: string) => (...args) => void}
 */
export declare function makeResolverInvoker<T>(resolver: Resolver<T>): (methodToInvoke: MethodName) => (this: Socket & {
    container: AwilixContainer;
}, ...rest: any[]) => any;
/**
 * Receives a member invoker and turns the event handler it returns into Socket.io middleware
 * Implementation is flexible in terms of arguments other than the socket but in reality there will
 * only be one other argument (the next callback)
 *
 * @export
 * @param {((this: Socket & { container: AwilixContainer }, ...rest: any[]) => any)} memberInvoker
 * @returns {*}
 */
export declare function adaptToMiddleware(memberInvoker: (this: Socket & {
    container: AwilixContainer;
}, ...rest: any[]) => any): (socket: Socket, ...rest: any[]) => any;
/**
 * Injects dependencies into the middleware factory when the middleware is invoked.
 *
 * @param factory
 */
export declare function inject(factory: ClassOrFunctionReturning<any> | Resolver<any>): (socket: Socket & {
    container: AwilixContainer;
}, ...rest: any[]) => any;
export {};
